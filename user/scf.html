

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>4.2. Self-consistent field (SCF) methods &mdash; PySCF 1.7.6 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4.3. Density functional theory (DFT)" href="dft.html" />
    <link rel="prev" title="4.1. Molecular structure" href="gto.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> PySCF
          

          
          </a>

          
            
            
              <div class="version">
                1.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. An overview of PySCF</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">3. Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../user.html">4. User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gto.html">4.1. Molecular structure</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.2. Self-consistent field (SCF) methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">4.2.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-guess">4.2.2. Initial guess</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#restart-from-an-old-calculation">4.2.2.1. Restart from an old calculation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#converging-scf-iterations">4.2.3. Converging SCF iterations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stability-analysis">4.2.4. Stability analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#property-calculations">4.2.5. Property calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spin-restricted-spin-unrestricted-restricted-open-shell-and-generalized-calculations">4.2.6. Spin-restricted, spin-unrestricted, restricted open-shell, and generalized calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linear-dependencies">4.2.7. Linear dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-relativistic-correction">4.2.8. Scalar relativistic correction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">4.2.9. References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dft.html">4.3. Density functional theory (DFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mp.html">4.4. Second-Order Møller–Plesset Perturbation Theory (MP2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="gw.html">4.5. GW approximation</a></li>
<li class="toctree-l2"><a class="reference internal" href="ci.html">4.6. Configuration interaction (CISD and FCI)</a></li>
<li class="toctree-l2"><a class="reference internal" href="cc.html">4.7. Coupled-cluster theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="adc.html">4.8. Algebraic diagrammatic construction (ADC) scheme</a></li>
<li class="toctree-l2"><a class="reference internal" href="agf2.html">4.9. Auxiliary second-order Green’s function perturbation theory (AGF2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="mcscf.html">4.10. Multi-configuration self-consistent field (MCSCF)</a></li>
<li class="toctree-l2"><a class="reference internal" href="tddft.html">4.11. Time-dependent Hartree-Fock and Density Functional Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="rt.html">4.12. Real-time time-dependent density functional theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvent.html">4.13. Solvation models</a></li>
<li class="toctree-l2"><a class="reference internal" href="qmmm.html">4.14. QM/MM methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="x2c.html">4.15. Relativistic calculations</a></li>
<li class="toctree-l2"><a class="reference internal" href="df.html">4.16. Density fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="pbc.html">4.17. Periodic boundary conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="eph.html">4.18. Electron Phonon Matrix</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../develop.html">5. Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">6. API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interface.html">7. Interfaces</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PySCF</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../user.html"><span class="section-number">4. </span>User guide</a> &raquo;</li>
        
      <li><span class="section-number">4.2. </span>Self-consistent field (SCF) methods</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/user/scf.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="self-consistent-field-scf-methods">
<span id="user-scf"></span><h1><span class="section-number">4.2. </span>Self-consistent field (SCF) methods<a class="headerlink" href="#self-consistent-field-scf-methods" title="Permalink to this headline">¶</a></h1>
<p><em>Modules</em>: <a class="reference internal" href="../modules/scf.html#module-scf" title="scf: restricted and unrestricted, closed shell and open shell Hartree-Fock methods"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scf</span></code></a>, <a class="reference internal" href="../modules/pbc/scf.html#module-pbc.scf" title="pbc.scf: Hartree-Fock methods with periodic boundary conditions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pbc.scf</span></code></a>, <a class="reference internal" href="../modules/soscf.html#module-soscf" title="soscf"><code class="xref py py-mod docutils literal notranslate"><span class="pre">soscf</span></code></a></p>
<div class="section" id="introduction">
<h2><span class="section-number">4.2.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Self-consistent field (SCF) methods include both Hartree-Fock (HF) theory
and Kohn-Sham (KS) density functional theory (DFT). Self-consistent
field theories only depend on the electronic density matrices, and are
the simplest level of quantum chemical models. Details that are
specific to DFT can be found in <a class="reference internal" href="dft.html#user-dft"><span class="std std-numref">Section 4.3</span></a>.</p>
<p>In both HF and KS-DFT, the ground-state wavefunction is expressed as a
single Slater determinant <span class="math notranslate nohighlight">\(\Phi_0\)</span> of molecular orbitals (MOs)
<span class="math notranslate nohighlight">\(\psi\)</span>, <span class="math notranslate nohighlight">\(\Phi_0 = \mathcal{A}|\psi_1(1)\psi_2(2) \ldots
\psi_N(N)|\)</span>. The total electronic energy
<span class="math notranslate nohighlight">\(E=\langle\Psi_0|\hat{H}|\Psi_0\rangle\)</span> is then minimized,
subject to orbital orthogonality; this is equivalent to the
description of the electrons as independent particles that only
interact via each others’ mean field.</p>
<p>It can be shown that the minimization of the total energy within a
given basis set (see e.g. <a class="bibtex reference internal" href="#lehtola2020-m-1218" id="id1">[1]</a> or any standard
textbook on quantum chemistry like <a class="bibtex reference internal" href="#szaost2012" id="id2">[2]</a>) leads to the
equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{F} \mathbf{C} = \mathbf{S} \mathbf{C} \mathbf{E}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> is the matrix of molecular orbital
coefficients, <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> is a diagonal matrix of the
corresponding eigenenergies, and <span class="math notranslate nohighlight">\(\mathbf{S}\)</span> is the atomic
orbital overlap matrix. The Fock matrix <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> is defined
as</p>
<div class="math notranslate nohighlight">
\[\mathbf{F} = \mathbf{T} + \mathbf{V} + \mathbf{J} + \mathbf{K}\;\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{T}\)</span> is the kinetic energy matrix,
<span class="math notranslate nohighlight">\(\mathbf{V}\)</span> is the external potential, <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> is
the Coulomb matrix, and <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the exchange matrix.</p>
</div>
<div class="section" id="initial-guess">
<h2><span class="section-number">4.2.2. </span>Initial guess<a class="headerlink" href="#initial-guess" title="Permalink to this headline">¶</a></h2>
<p>The Coulomb and exchange matrices depend on the occupied orbitals,
meaning that the SCF equation <span class="math notranslate nohighlight">\(\mathbf{F C}=\mathbf{S C E}\)</span>
needs to be solved self-consistently by some sort of iterative
procedure, which begins from some initial guess. The accuracy of
several initial guesses for SCF calculations has recently been
assessed in <a class="bibtex reference internal" href="#lehtola2019-jctc-1593" id="id3">[3]</a>, to which we refer for
detailed discussion on initial guesses.</p>
<p>Several of initial guess have been implemented in PySCF; the used
variant is controlled by the <code class="xref py py-attr docutils literal notranslate"><span class="pre">init_guess</span></code> attribute of the SCF
solver. The following values are possible</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'minao'</span></code> (default)</p>
<blockquote>
<div><p>Superposition of atomic densities projected in a minimal basis
obtained from the first contracted functions in the cc-pVTZ or
cc-pVTZ-PP basis set. The guess orbitals are obtained by
diagonalizing the Fock matrix that arises from the spin-restricted
guess density.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'1e'</span></code></p>
<blockquote>
<div><p>The one-electron guess, also known as the core guess, obtains the
guess orbitals from the diagonalization of the core Hamiltonian
<span class="math notranslate nohighlight">\(\mathbf{H}_0 = \mathbf{T} + \mathbf{V}\)</span>, thereby ignoring
all interelectronic interactions and the screening of nuclear
charge. The 1e guess should only be used as a last resort, because
it is so bad for molecular systems; see
<a class="bibtex reference internal" href="#lehtola2019-jctc-1593" id="id4">[3]</a>.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'atom'</span></code></p>
<blockquote>
<div><p>Superposition of atomic HF density matrices. The atomic HF
calculations are spin-restricted and employ spherically averaged
fractional occupations with ground states determined with fully
numerical calculations at the complete basis set limit in
<a class="bibtex reference internal" href="#lehtola2020-pra-012516" id="id5">[4]</a>.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'huckel'</span></code></p>
<blockquote>
<div><p>This is the parameter-free Hückel guess described in
<a class="bibtex reference internal" href="#lehtola2019-jctc-1593" id="id6">[3]</a>, which is based on on-the-fly atomic
HF calculations that are performed analogously to <code class="docutils literal notranslate"><span class="pre">'atom'</span></code>. The
spherically averaged atomic spin-restricted Hartree-Fock
calculations yield a minimal basis of atomic orbitals and orbital
energies, which are used to build a Hückel type matrix that is
diagonalized to obtain guess orbitals.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'vsap'</span></code></p>
<blockquote>
<div><p>Superposition of atomic potentials as described in
<a class="bibtex reference internal" href="#lehtola2019-jctc-1593" id="id7">[3]</a>. Pretabulated, fully numerical
atomic potentials determined with the approach of
<a class="bibtex reference internal" href="#lehtola2020-pra-012516" id="id8">[4]</a> are used to build a guess potential
on a DFT quadrature grid; this potential is then used to obtain
the orbitals. Note this option is only available for DFT
calculations in PySCF.</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'chk'</span></code></p>
<blockquote>
<div><p>Read in the orbitals from the checkpoint file and use them as the
initial guess (see below for more details).</p>
</div></blockquote>
</li>
</ul>
<p>Alternatively, the user can also override the initial guess density
matrix for an SCF calculation through the <code class="docutils literal notranslate"><span class="pre">dm0</span></code> argument.  For
example, the following script first computes the HF density matrix for
the <span class="math notranslate nohighlight">\(\rm Cr^{6+}\)</span> cation, and then uses it as an initial guess
for a HF calculation of the <span class="math notranslate nohighlight">\(\rm Cr\)</span> atom.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># First calculate the Cr6+ cation</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span>
    <span class="n">symmetry</span> <span class="o">=</span> <span class="s1">&#39;D2h&#39;</span><span class="p">,</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;Cr&#39;</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">],</span>
    <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;cc-pvdz&#39;</span><span class="p">,</span>
    <span class="n">charge</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">spin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">dm1</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>

<span class="c1"># Now switch to the neutral atom in the septet state</span>
<span class="n">mol</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">mol</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm0</span><span class="o">=</span><span class="n">dm1</span><span class="p">)</span>
</pre></div>
</div>
<p>More examples can be found in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/15-initial_guess.py">examples/scf/15-initial_guess.py</a>, and
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/31-cr_atom_rohf_tune_init_guess.py">examples/scf/31-cr_atom_rohf_tune_init_guess.py</a>.</p>
<div class="section" id="restart-from-an-old-calculation">
<h3><span class="section-number">4.2.2.1. </span>Restart from an old calculation<a class="headerlink" href="#restart-from-an-old-calculation" title="Permalink to this headline">¶</a></h3>
<p>Although alike many other quantum chemistry codes, there is no
<cite>restart</cite> mechanism available in PySCF package, calculations can still
be “restarted” by reading in an earlier wave function as the initial
guess for the wave function.  The initial guess can be prepared in
many ways.  One is to read the <code class="docutils literal notranslate"><span class="pre">chkpoint</span></code> file which is generated in
the previous or other calculations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s1">&#39;/path/to/chkfile&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">init_guess</span> <span class="o">=</span> <span class="s1">&#39;chkfile&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">/path/to/chkfile</span></code> can be found in the output in the calculation (if
<code class="docutils literal notranslate"><span class="pre">mol.verbose</span> <span class="pre">&gt;=</span> <span class="pre">4</span></code>, the filename of the chkfile will be dumped in
the output).  If the results of the calculation are needed at a later
stage (e.g. for an eventual restart or use as an initial guess for a
larger calculation), the <code class="xref py py-attr docutils literal notranslate"><span class="pre">chkfile</span></code> attribute should be set
explicitly as the chkfile might otherwise be deleted upon successful
completion of the calculation, see comments in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/14-restart.py">examples/scf/14-restart.py</a>.
By setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">chkfile</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">init_guess</span></code>, the
SCF module can read the molecular orbitals from the given
<code class="xref py py-attr docutils literal notranslate"><span class="pre">chkfile</span></code> and rotate them to representation of the required
basis.</p>
<p>The initial guess can also be fed in directly to the calculation. For
example, we can read in the density matrix from a checkpoint file, and
pass it directly to the SCF solver with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">from_chk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="s1">&#39;/path/to/chkfile&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
<p>This approach leads to the same result as setting <code class="xref py py-attr docutils literal notranslate"><span class="pre">init_guess</span></code>
to <cite>chkfile</cite>.</p>
<p>N.B. The <code class="docutils literal notranslate"><span class="pre">chkfile</span></code> initial guess is not limited to calculations on
the same molecule or the same basis set. One can first do a cheaper
SCF calculation with smaller basis sets, or run an SCF calculation on
a model system (e.g. drop a few atoms or run the same system in an
easier charge/spin state), then use <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.from_chk()</span></code> to project
the results to the target basis sets.</p>
</div>
</div>
<div class="section" id="converging-scf-iterations">
<h2><span class="section-number">4.2.3. </span>Converging SCF iterations<a class="headerlink" href="#converging-scf-iterations" title="Permalink to this headline">¶</a></h2>
<p>Even with a very good initial guess, making the SCF procedure converge
is sometimes challenging. PySCF implements two kinds of approaches for
SCF, namely, direct inversion in the iterative subspace (DIIS) and
second-order SCF (SOSCF).</p>
<ul>
<li><p>DIIS (default)</p>
<blockquote>
<div><p>With DIIS, the Fock matrix at each iteration is extrapolated using
Fock matrices from the previous iterations, by minimizing the norm
of the commutator <span class="math notranslate nohighlight">\([\mathbf{F},\mathbf{PS}]\)</span> where
<span class="math notranslate nohighlight">\(\mathbf{P}\)</span> is the density matrix
<a class="bibtex reference internal" href="#pulay1980-cpl-393" id="id9">[5]</a><a class="bibtex reference internal" href="#pulay1982-jcc-556" id="id10">[6]</a>.  Two variants of DIIS
are implemented in PySCF, namely, EDIIS <a class="bibtex reference internal" href="#kudin2002-jcp-8255" id="id11">[7]</a>
and ADIIS <a class="bibtex reference internal" href="#hu2010-jcp-054109" id="id12">[8]</a>.  Examples of selecting
different DIIS schemes can be found in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/24-tune_diis.py">examples/scf/24-tune_diis.py</a>.</p>
</div></blockquote>
</li>
<li><p>SOSCF</p>
<blockquote>
<div><p>To achieve quadratic convergence in the orbital optimization,
PySCF implements a general second-order solver called the
co-iterative augmented hessian (CIAH) method
<a class="bibtex reference internal" href="#sun2016" id="id13">[9]</a><a class="bibtex reference internal" href="#sun2017-cpl-291" id="id14">[10]</a>. This method can be invoked by
decorating the SCF objects with the <a class="reference internal" href="../modules/soscf.html#pyscf.soscf.newton_ah.newton" title="pyscf.soscf.newton_ah.newton"><code class="xref py py-func docutils literal notranslate"><span class="pre">newton()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">newton</span><span class="p">()</span>
</pre></div>
</div>
<p>More examples can be found in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/22-newton.py">examples/scf/22-newton.py</a>.</p>
</div></blockquote>
</li>
<li><p>Damping</p>
<blockquote>
<div><p>The Fock matrix can be damped before DIIS acceleration kicks in.
This is achieved by setting the attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">damp</span></code> and
<code class="xref py py-attr docutils literal notranslate"><span class="pre">diis_start_cycle</span></code>.  For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span><span class="o">.</span><span class="n">damp</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">mf</span><span class="o">.</span><span class="n">diis_start_cycle</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>means that DIIS will start at the second cycle, and that the Fock
matrix is damped by 50% in the first cycle.</p>
</div></blockquote>
</li>
<li><p>Level shifting</p>
<blockquote>
<div><p>A level shift increases the gap between the occupied and virtual
orbitals, thereby slowing down and stabilizing the orbital update.
A level shift can help to converge SCF in the case of systems with
small HOMO-LUMO gaps. Level shifting is invoked by setting the
attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">level_shift</span></code>.  See examples in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/03-level_shift.py">examples/scf/03-level_shift.py</a>, and
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/52-dynamically_control_level_shift.py">examples/scf/52-dynamically_control_level_shift.py</a>.</p>
</div></blockquote>
</li>
<li><p>Fractional occupations</p>
<blockquote>
<div><p>Fractional occupations can also be invoked to help the SCF
converge for small gap systems.  See the example in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/54-fractional_occupancy.py">examples/scf/54-fractional_occupancy.py</a>.</p>
</div></blockquote>
</li>
<li><p>Smearing</p>
<blockquote>
<div><p>Smearing sets fractional occupancies according to a temperature
function. See the example <a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/pbc/23-smearing.py">examples/pbc/23-smearing.py</a>.</p>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="stability-analysis">
<span id="id15"></span><h2><span class="section-number">4.2.4. </span>Stability analysis<a class="headerlink" href="#stability-analysis" title="Permalink to this headline">¶</a></h2>
<p>Even when the SCF converges, the wave function that is found may not
correspond to a local minimum; calculations can sometimes also
converge onto saddle points. Since saddle points are also extrema of
the energy functional, the orbital gradient vanishes and the SCF
equation <span class="math notranslate nohighlight">\(\mathbf{F C}=\mathbf{S C E}\)</span> is satisfied
<a class="bibtex reference internal" href="#lehtola2020-m-1218" id="id16">[1]</a>. However, in such cases the energy can be
decreased by perturbing the orbitals away from the saddle point, which
means that the wave function is unstable.</p>
<p>Instabilities in the wave function are conventionally classified as
either internal or external <a class="bibtex reference internal" href="#seeger1977-jcp-3045" id="id17">[11]</a>. External
instabilities mean that the energy can be decreased by loosening some
constraints on the wave function, such as allowing restricted
Hartree-Fock orbitals to transform into unrestricted Hartree-Fock,
whereas internal instabilities mean that the SCF has converged onto an
excited state instead of the ground state. PySCF allows detecting both
internal and external instabilities for a given SCF calculation; see
the examples in <a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/17-stability.py">examples/scf/17-stability.py</a>.</p>
</div>
<div class="section" id="property-calculations">
<h2><span class="section-number">4.2.5. </span>Property calculations<a class="headerlink" href="#property-calculations" title="Permalink to this headline">¶</a></h2>
<p>Various properties can be computed by calling the corresponding
functions, for example,</p>
<ul>
<li><p>dipole moment:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span><span class="o">.</span><span class="n">dip_moment</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>Mulliken population:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span><span class="o">.</span><span class="n">mulliken_pop</span><span class="p">()</span>
</pre></div>
</div>
</li>
<li><p>nuclear gradients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">Gradients</span><span class="p">()</span>
<span class="n">g</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
<p>Also several response properties are available in PySCF, see the
examples in <a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/prop/17-stability.py">examples/prop/17-stability.py</a>.</p>
</div>
<div class="section" id="spin-restricted-spin-unrestricted-restricted-open-shell-and-generalized-calculations">
<h2><span class="section-number">4.2.6. </span>Spin-restricted, spin-unrestricted, restricted open-shell, and generalized calculations<a class="headerlink" href="#spin-restricted-spin-unrestricted-restricted-open-shell-and-generalized-calculations" title="Permalink to this headline">¶</a></h2>
<p>The general spin-orbital used in the HF or KS-DFT wave function can be
written as</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\psi_i(1) = \phi_{i\alpha}(r)\alpha + \phi_{i\beta}(r)\beta \;,\]</div>
</div></blockquote>
<p>Four variants of the ansatz <span class="math notranslate nohighlight">\(\psi(1)\)</span> are commonly used in
quantum chemistry; they are also all available in PySCF.</p>
<ul>
<li><p>Restricted (RHF/RKS)</p>
<p>The spin-orbitals are either alpha (spin-up) or beta (spin-down),
<span class="math notranslate nohighlight">\(\psi_i =\phi_i(r)\alpha\)</span> or <span class="math notranslate nohighlight">\(\psi_i = \phi_i(r)\beta\)</span>,
and the alpha and beta orbitals share the same spatial orbital
<span class="math notranslate nohighlight">\(\phi_i(r)\)</span>. The closed-shell determinant is thus
<span class="math notranslate nohighlight">\(\Phi=\mathcal{A}|\phi_1(r_1)\alpha \phi_1(r_2)\beta \ldots
\phi_{N/2}(r_{N-1})\alpha \phi_{N/2}(r_N)\beta|\)</span> and <span class="math notranslate nohighlight">\(S=0\)</span>.</p>
</li>
<li><p>Unrestricted (UHF/UKS)</p>
<p>The orbitals can have either alpha or beta spin, but the alpha and
beta orbitals may have different spatial components. The determinant
is thus <span class="math notranslate nohighlight">\(\Phi=\mathcal{A}|\phi_1(r_1)\sigma_1
\phi_2(r_2)\sigma_2 \ldots \phi_{N}(r_N)\sigma_N|\)</span> where
<span class="math notranslate nohighlight">\(\sigma \in \{\alpha,\beta\}\)</span>.  Spin contamination is
introduced for states that don’t have maximal <span class="math notranslate nohighlight">\(S_z\)</span>.</p>
</li>
<li><p>Restricted open-shell (ROHF/ROKS)</p>
<p>Equivalent to RHF/RKS for <span class="math notranslate nohighlight">\(N_\alpha = N_\beta\)</span>.  For
<span class="math notranslate nohighlight">\(N_\alpha &gt; N_\beta\)</span>, the first <span class="math notranslate nohighlight">\(N_\beta\)</span> orbitals have
the same spatial components for both <span class="math notranslate nohighlight">\(\alpha\)</span> and
<span class="math notranslate nohighlight">\(\beta\)</span> spin. The remaining <span class="math notranslate nohighlight">\(N_\alpha - N_\beta\)</span>
orbitals are of <span class="math notranslate nohighlight">\(\alpha\)</span> spin.  <span class="math notranslate nohighlight">\(\Phi=\mathcal{A}|\phi_1
\alpha \phi_1\beta \ldots \phi_{N_\beta} \alpha \phi_{N_\beta}\beta
\phi_{N_\beta+1}\alpha \ldots \phi_{N}\alpha|\)</span> The final
wavefunction is an eigenfunction of the <span class="math notranslate nohighlight">\(\hat{S}^2\)</span> operator
with <span class="math notranslate nohighlight">\(S_z=S\)</span>.</p>
</li>
<li><p>Generalized (GHF/GKS)</p>
<p>The general form of the spin-orbital <span class="math notranslate nohighlight">\(\psi\)</span> is used. GHF/GKS
is useful when none of the previous methods provide stable solutions
(see <a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/17-stability.py">examples/scf/17-stability.py</a>), or when the
Hamiltonian does not commute with <span class="math notranslate nohighlight">\(\hat{S}_z\)</span> (e.g. in the
presence of spin-orbit coupling, see
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/44-soc_ecp.py">examples/scf/44-soc_ecp.py</a>).</p>
</li>
</ul>
<p>Calculations with these methods can be invoked by creating an instance
of the corresponding class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">ROHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">GHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">ROKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">GKS</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>More examples can be found in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/00-simple_hf.py">examples/scf/00-simple_hf.py</a>,
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/01-h2o.py">examples/scf/01-h2o.py</a>,
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/02-rohf_uhf.py">examples/scf/02-rohf_uhf.py</a>, and
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/02-ghf.py">examples/scf/02-ghf.py</a>.</p>
</div>
<div class="section" id="linear-dependencies">
<h2><span class="section-number">4.2.7. </span>Linear dependencies<a class="headerlink" href="#linear-dependencies" title="Permalink to this headline">¶</a></h2>
<p>Most quantum chemistry programs solve the self-consistent field
equations</p>
<div class="math notranslate nohighlight">
\[\mathbf{F} \mathbf{C} = \mathbf{S} \mathbf{C} \mathbf{E}\]</div>
<p>in an orthonormal basis, which is formally obtained as</p>
<div class="math notranslate nohighlight">
\[\mathbf{C} = \mathbf{X} \tilde{\mathbf{C}}\]</div>
<p>where the orthogonalizing matrix <span class="math notranslate nohighlight">\(\mathbf{X}\)</span> is typically
chosen as <span class="math notranslate nohighlight">\(\mathbf{X}=\mathbf{S}^{-1/2}\)</span>. By expressing the
orbitals in terms of the half-inverse overlap matrix, the generalized
eigenproblem <span class="math notranslate nohighlight">\(\mathbf{F} \mathbf{C} = \mathbf{S} \mathbf{C}
\mathbf{E}\)</span> can be rewritten as a regular eigenproblem
<span class="math notranslate nohighlight">\(\tilde{\mathbf{F}} \tilde{\mathbf{C}} = \tilde{\mathbf{C}}
\mathbf{E}\)</span> <a class="bibtex reference internal" href="#lehtola2020-m-1218" id="id18">[1]</a>.</p>
<p>Moreover, as the half-inverse overlap matrix <span class="math notranslate nohighlight">\(\mathbf{S}^{-1/2}\)</span>
is typically formed by the canonical orthonormalization procedure
<a class="bibtex reference internal" href="#lowdin1970-aqc-185" id="id19">[12]</a> in which eigenvectors of the overlap matrix
with small eigenvalues are thrown out, this procedure typically
results in a better-conditioned basis since linearly dependent
combinations of the basis functions are excluded by the procedure.</p>
<p>At variance, PySCF relies on SciPy’s generalized eigenvalue solver by
default, which may fail for poorly conditioned basis sets. One can,
however, switch to the use of canonical orthonormalization by toggling
e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">addons</span><span class="o">.</span><span class="n">remove_linear_dep_</span><span class="p">)</span>
</pre></div>
</div>
<p>In the presence of truly pathological linear dependencies, such as
those that occur in molecular calculations with multiply augmented
basis sets, and at extreme molecular geometries where two nuclei are
close to each other, also canonical orthonormalization fails.
However, the addons module also implements the partial Cholesky
orthonormalization technique
<a class="bibtex reference internal" href="#lehtola2019-jcp-241102" id="id20">[13]</a><a class="bibtex reference internal" href="#lehtola2020-pra-032504" id="id21">[14]</a>, which has been
shown to work reliably even in the presence of such truly pathological
linear dependencies.</p>
</div>
<div class="section" id="scalar-relativistic-correction">
<h2><span class="section-number">4.2.8. </span>Scalar relativistic correction<a class="headerlink" href="#scalar-relativistic-correction" title="Permalink to this headline">¶</a></h2>
<p>Scalar relativistic effects can be applied on the one-body operators
through spin-free eXact-2-component (SFX2C) Hamiltonian
<a class="bibtex reference internal" href="#dyall2001interfacing" id="id22">[15]</a>.  The SFX2C Hamiltonian can be invoked by
decorating the SCF objects with the <code class="xref py py-func docutils literal notranslate"><span class="pre">x2c()</span></code> method, three other
equivalent function names are also listed below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">x2c</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">x2c1e</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">sfx2c</span><span class="p">()</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">sfx2c1e</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that the SFX2C Hamiltonian only changes the one-body operators,
and it only accounts for the mass-velocity effect, while picture
change effect and spin-orbit coupling are not included.  Once the SCF
object is decorated by <code class="xref py py-func docutils literal notranslate"><span class="pre">x2c()</span></code> method, the corresponding post-SCF
objects will also automatically have the SFX2C Hamiltonian applied.
To turn it off explicitly, one can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mf</span><span class="o">.</span><span class="n">with_x2c</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>More examples can be found in
<a class="reference external" href="https://github.com/pyscf/pyscf/tree/master/examples/scf/21-x2c.py">examples/scf/21-x2c.py</a>.</p>
</div>
<div class="section" id="references">
<h2><span class="section-number">4.2.9. </span>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<p id="bibtex-bibliography-user/scf-0"><dl class="citation">
<dt class="bibtex label" id="lehtola2020-m-1218"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id16">2</a>,<a href="#id18">3</a>)</span></dt>
<dd><p>Susi Lehtola, Frank Blockhuys, and Christian Van Alsenoy. An overview of self-consistent field calculations within finite basis sets. <em>Molecules</em>, 2020. <a class="reference external" href="https://doi.org/10.3390/molecules25051218">doi:10.3390/molecules25051218</a>.</p>
</dd>
<dt class="bibtex label" id="szaost2012"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Attila Szabo and Neil S Ostlund. <em>Modern quantum chemistry: introduction to advanced electronic structure theory</em>. Courier Corporation, 2012.</p>
</dd>
<dt class="bibtex label" id="lehtola2019-jctc-1593"><span class="brackets">3</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>,<a href="#id6">3</a>,<a href="#id7">4</a>)</span></dt>
<dd><p>Susi Lehtola. Assessment of initial guesses for self-consistent field calculations. Superposition of atomic potentials: simple yet efficient. <em>J. Chem. Theory Comput.</em>, 15:1593, 2019. <a class="reference external" href="https://doi.org/10.1021/acs.jctc.8b01089">doi:10.1021/acs.jctc.8b01089</a>.</p>
</dd>
<dt class="bibtex label" id="lehtola2020-pra-012516"><span class="brackets">4</span><span class="fn-backref">(<a href="#id5">1</a>,<a href="#id8">2</a>)</span></dt>
<dd><p>Susi Lehtola. Fully numerical calculations on atoms with fractional occupations and range-separated exchange functionals. <em>Phys. Rev. A</em>, 101:012516, 2020. <a class="reference external" href="https://doi.org/10.1103/PhysRevA.101.012516">doi:10.1103/PhysRevA.101.012516</a>.</p>
</dd>
<dt class="bibtex label" id="pulay1980-cpl-393"><span class="brackets"><a class="fn-backref" href="#id9">5</a></span></dt>
<dd><p>Péter Pulay. Convergence acceleration of iterative sequences. The case of SCF iteration. <em>Chem. Phys. Lett.</em>, 73:393, 1980. <a class="reference external" href="https://doi.org/10.1016/0009-2614(80)80396-4">doi:10.1016/0009-2614(80)80396-4</a>.</p>
</dd>
<dt class="bibtex label" id="pulay1982-jcc-556"><span class="brackets"><a class="fn-backref" href="#id10">6</a></span></dt>
<dd><p>P. Pulay. Improved SCF convergence acceleration. <em>J. Comput.. Chem.</em>, 3:556, 1982. <a class="reference external" href="https://doi.org/10.1002/jcc.540030413">doi:10.1002/jcc.540030413</a>.</p>
</dd>
<dt class="bibtex label" id="kudin2002-jcp-8255"><span class="brackets"><a class="fn-backref" href="#id11">7</a></span></dt>
<dd><p>Konstantin N. Kudin, Gustavo E. Scuseria, and Eric Cancès. A black-box self-consistent field convergence algorithm: One step closer. <em>J. Chem. Phys.</em>, 116(19):8255, 2002. <a class="reference external" href="https://doi.org/10.1063/1.1470195">doi:10.1063/1.1470195</a>.</p>
</dd>
<dt class="bibtex label" id="hu2010-jcp-054109"><span class="brackets"><a class="fn-backref" href="#id12">8</a></span></dt>
<dd><p>Xiangqian Hu and Weitao Yang. Accelerating self-consistent field convergence with the augmented Roothaan–Hall energy function. <em>J. Chem. Phys.</em>, 132:054109, 2010. <a class="reference external" href="https://doi.org/10.1063/1.3304922">doi:10.1063/1.3304922</a>.</p>
</dd>
<dt class="bibtex label" id="sun2016"><span class="brackets"><a class="fn-backref" href="#id13">9</a></span></dt>
<dd><p>Qiming Sun. Co-iterative augmented Hessian method for orbital optimization. <em>arXiv preprint arXiv:1610.08423</em>, 2016.</p>
</dd>
<dt class="bibtex label" id="sun2017-cpl-291"><span class="brackets"><a class="fn-backref" href="#id14">10</a></span></dt>
<dd><p>Qiming Sun, Jun Yang, and Garnet Kin-Lic Chan. A general second order complete active space self-consistent-field solver for large-scale systems. <em>Chem. Phys. Lett.</em>, 683:291, 2017. <a class="reference external" href="https://doi.org/10.1016/j.cplett.2017.03.004">doi:10.1016/j.cplett.2017.03.004</a>.</p>
</dd>
<dt class="bibtex label" id="seeger1977-jcp-3045"><span class="brackets"><a class="fn-backref" href="#id17">11</a></span></dt>
<dd><p>Rolf Seeger and John A. Pople. Self-consistent molecular orbital methods. XVIII. Constraints and stability in Hartree–Fock theory. <em>J. Chem. Phys.</em>, 66:3045, 1977. <a class="reference external" href="https://doi.org/10.1063/1.434318">doi:10.1063/1.434318</a>.</p>
</dd>
<dt class="bibtex label" id="lowdin1970-aqc-185"><span class="brackets"><a class="fn-backref" href="#id19">12</a></span></dt>
<dd><p>Per-Olov Löwdin. On the nonorthogonality problem. <em>Adv. Quantum Chem.</em>, 5:185, 1970. <a class="reference external" href="https://doi.org/10.1016/S0065-3276(08)60339-1">doi:10.1016/S0065-3276(08)60339-1</a>.</p>
</dd>
<dt class="bibtex label" id="lehtola2019-jcp-241102"><span class="brackets"><a class="fn-backref" href="#id20">13</a></span></dt>
<dd><p>Susi Lehtola. Curing basis set overcompleteness with pivoted cholesky decompositions. <em>J. Chem. Phys.</em>, 151(24):241102, 2019. <a class="reference external" href="https://doi.org/10.1063/1.5139948">doi:10.1063/1.5139948</a>.</p>
</dd>
<dt class="bibtex label" id="lehtola2020-pra-032504"><span class="brackets"><a class="fn-backref" href="#id21">14</a></span></dt>
<dd><p>Susi Lehtola. Accurate reproduction of strongly repulsive interatomic potentials. <em>Phys. Rev. A</em>, 101:032504, 2020. <a class="reference external" href="https://doi.org/10.1103/PhysRevA.101.032504">doi:10.1103/PhysRevA.101.032504</a>.</p>
</dd>
<dt class="bibtex label" id="dyall2001interfacing"><span class="brackets"><a class="fn-backref" href="#id22">15</a></span></dt>
<dd><p>Kenneth G Dyall. Interfacing relativistic and nonrelativistic methods. iv. one-and two-electron scalar approximations. <em>The Journal of Chemical Physics</em>, 115(20):9136–9143, 2001.</p>
</dd>
</dl>
</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="dft.html" class="btn btn-neutral float-right" title="4.3. Density functional theory (DFT)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="gto.html" class="btn btn-neutral float-left" title="4.1. Molecular structure" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2015-2021, The PySCF Developers.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>